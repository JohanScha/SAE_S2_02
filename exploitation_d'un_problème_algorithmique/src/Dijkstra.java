import java.util.ArrayList;

/**
 * Classe qui implémente l'algorithme de Dijkstra.
 *
 * Cet algorithme sert à trouver les plus courts chemins depuis un point de départ
 * vers tous les autres nœuds d'un graphe avec des arcs à poids positifs.
 */
public class Dijkstra {

    /**
     * Applique l'algorithme de Dijkstra sur un graphe à poids positifs.
     *
     * @param g le graphe
     * @param depart le nom du noeud de départ
     * @return un objet Valeurs contenant les distances minimales et les parents
     */
    public Valeurs resoudre(Graphe g, String depart) {
        Valeurs valeurs = new Valeurs(); // distances + parents
        ArrayList<String> Q = new ArrayList<>(); // liste des noeuds à traiter

        // 1. Initialisation des valeurs
        for (String noeud : g.listeNoeuds()) {
            valeurs.setValeur(noeud, Double.MAX_VALUE);
            valeurs.setParent(noeud, null);
            Q.add(noeud); // on ajoute tous les noeuds à la liste Q
        }
        valeurs.setValeur(depart, 0); // le départ vaut 0

        // 2. Boucle principale de Dijkstra
        while (!Q.isEmpty()) {
            // Trouver le noeud u dans Q avec la plus petite valeur
            String u = Q.get(0);
            for (int i = 1; i < Q.size(); i++) {
                String c = Q.get(i); // Recupere le ième noeud
                if (valeurs.getValeur(c) < valeurs.getValeur(u)) { // comparaison des distances
                    u = c;
                }
            }

            // Enlever u de Q
            Q.remove(u);

            // Pour chaque voisin v de u (arc u → v)
            for (Arc arc : g.suivants(u)) {
                String v = arc.getDest();
                if (Q.contains(v)) { // v est encore dans Q
                    double d = valeurs.getValeur(u) + arc.getCout();
                    if (d < valeurs.getValeur(v)) {
                        valeurs.setValeur(v, d);     // meilleure distance
                        valeurs.setParent(v, u);     // meilleur chemin
                    }
                }
            }
        }

        // 3. Retour du résultat
        return valeurs;
    }

    /**
     * Applique l'algorithme de Dijkstra sur un graphe à poids positifs.
     * Ici on mettera une penalité de 10 si on change de ligne
     *
     * @param g le graphe
     * @param depart le nom du noeud de départ
     * @return un objet Valeurs contenant les distances minimales et les parents
     */
    public Valeurs resoudre2(Graphe g, String depart){
        Valeurs valeurs = new Valeurs(); // distances + parents
        ArrayList<String> Q = new ArrayList<>(); // liste des noeuds à traiter

        // 1. Initialisation des valeurs
        for (String noeud : g.listeNoeuds()) {
            valeurs.setValeur(noeud, Double.MAX_VALUE);
            valeurs.setParent(noeud, null);
            Q.add(noeud); // on ajoute tous les noeuds à la liste Q
        }
        valeurs.setValeur(depart, 0); // le départ vaut 0

        // 2. Boucle principale de Dijkstra
        while (!Q.isEmpty()) {
            // Trouver le noeud u dans Q avec la plus petite valeur
            String u = Q.get(0);
            for (int i = 1; i < Q.size(); i++) {
                String c = Q.get(i); // Recupere le ième noeud
                if (valeurs.getValeur(c) < valeurs.getValeur(u)) { // comparaison des distances
                    u = c;
                }
            }

            // Enlever u de Q
            Q.remove(u);
            //Parcours de la liste d'arcs
            for (Arc arc : g.suivants(u)) {
                String v = arc.getDest();
                // si le sommet v est encore à traiter
                if (Q.contains(v)) {
                    double cout = arc.getCout();

                    // Vérifier si on doit ajouter une pénalité de changement de ligne
                    String parent = valeurs.getParent(u);
                    if (parent != null) {

                        // On retrouve l'arc parent pour connaître la ligne empruntée avant
                        for (Arc arcVersU : g.suivants(parent)) {
                            if (arcVersU.getDest().equals(u)) {
                                String ligneAvant = arcVersU.getLigne();
                                String ligneActuelle = arc.getLigne();

                                // Si les lignes sont différentes, on ajoute la pénalité
                                if (ligneAvant != null && ligneActuelle != null && !ligneAvant.equals(ligneActuelle)) {
                                    cout += 10;
                                }
                                break;
                            }
                        }
                    }

                    // Pour chaque voisin v de u (arc u → v)
                    double d = valeurs.getValeur(u) + cout;
                    if (d < valeurs.getValeur(v)) {
                        valeurs.setValeur(v, d); // meilleure distance
                        valeurs.setParent(v, u);// meilleur chemin
                    }
                }
            }
        }


        // 3. Retour du résultat
        return valeurs;
    }

    /**
     * Retourne le coût total du chemin entre depart et destination,
     * en utilisant les valeurs calculées par l'algorithme de Dijkstra.
     *
     * @param depart la station de départ
     * @param destination la station d'arrivée
     * @param valeurs l'objet Valeurs retourné par resoudre()
     * @return le coût total du chemin, ou Double.MAX_VALUE si aucun chemin n'existe
     */
    public double coutChemin(String depart, String destination, Valeurs valeurs) {
        // Vérification si un chemin existe
        if (valeurs.getValeur(destination) == Double.MAX_VALUE || valeurs.getParent(destination) == null) {
            return Double.MAX_VALUE; // Aucun chemin trouvé
        }

        return valeurs.getValeur(destination);
    }


}
