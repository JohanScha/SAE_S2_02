import java.util.*;
import java.io.*;

/**
 * Classe principale qui applique Bellman-Ford et Dijkstra à 5 trajets du métro parisien.
 * Affiche les résultats avec et sans pénalité de changement de ligne.
 */
public class MainMetro {

    public static void main(String[] args) throws IOException {
        String fichier = "exploitation_d'un_problème_algorithmique/Documents/plan-reseau.txt";
        GrapheListe graphe = LireReseau.lire(fichier);
        ArrayList<String[]> stations = lireStations(fichier);

        List<String[]> trajets = List.of(
                new String[]{"Château de Vincennes", "Bérault"},
                new String[]{"Porte Dauphine", "Nation"},
                new String[]{"Pont de Neuilly", "République"},
                new String[]{"Concorde", "Porte d'Orléans"},
                new String[]{"Place d'Italie", "Pont-Marie"}
        );

        System.out.println("\n--> Résultats SANS pénalité de changement de ligne :\n");
        afficherResultats(graphe, stations, trajets, false);

        System.out.println("\n--> Résultats AVEC pénalité de changement de ligne :\n");
        afficherResultats(graphe, stations, trajets, true);
    }

    /**
     * Affiche les résultats (chemin, temps et coût) pour une liste de trajets.
     */
    public static void afficherResultats(Graphe graphe, ArrayList<String[]> stations, List<String[]> trajets, boolean avecPenalite) {
        System.out.printf("%-25s %-25s %-45s %-20s %-20s %-15s %-15s\n",
                "Départ", "Arrivée", "Chemin (IDs)", "Bellman-Ford (ms)", "Dijkstra (ms)", "Coût BF", "Coût Dijkstra");
        System.out.println("---------------------------------------------------------------------------------------------------------------------------------------");

        for (String[] trajet : trajets) {
            String depart = trajet[0];
            String arrivee = trajet[1];

            // Bellman-Ford
            long debutBF = System.nanoTime();
            Valeurs valBF = avecPenalite ?
                    new BellmanFord().resoudre2(graphe, depart) :
                    new BellmanFord().resoudre(graphe, depart);
            long finBF = System.nanoTime();
            List<String> cheminBF = valBF.calculerChemin(arrivee, depart);
            double tempsBF = (finBF - debutBF) / 1_000_000.0;
            double coutBF = valBF.getValeur(arrivee);

            // Dijkstra
            long debutD = System.nanoTime();
            Valeurs valD = avecPenalite ?
                    new Dijkstra().resoudre2(graphe, depart) :
                    new Dijkstra().resoudre(graphe, depart);
            long finD = System.nanoTime();
            List<String> cheminD = valD.calculerChemin(arrivee, depart);
            double tempsD = (finD - debutD) / 1_000_000.0;
            double coutD = valD.getValeur(arrivee);

            // Remplacer Map par ArrayList de stations
            List<String> cheminIds = new ArrayList<>();
            for (String nom : cheminD) {
                String idTrouve = "?";
                for (String[] station : stations) {
                    if (station[1].equals(nom)) {
                        idTrouve = station[0];
                        break;
                    }
                }
                cheminIds.add(idTrouve);
            }

            // Join manuel pour éviter String.join()
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < cheminIds.size(); i++) {
                sb.append(cheminIds.get(i));
                if (i < cheminIds.size() - 1) {
                    sb.append(" → ");
                }
            }
            String cheminStr = sb.toString();
            if (cheminStr.length() > 43) {
                cheminStr = cheminStr.substring(0, 40) + "...";
            }

            System.out.printf("%-25s %-25s %-45s %-20.2f %-20.2f %-15.2f %-15.2f\n",
                    depart, arrivee, cheminStr, tempsBF, tempsD, coutBF, coutD);
        }
    }

    /**
     * Lit les stations à partir du fichier et les retourne sous forme de liste [id, nom]
     */
    public static ArrayList<String[]> lireStations(String fichier) throws IOException {
        ArrayList<String[]> stations = new ArrayList<>();
        BufferedReader br = new BufferedReader(new FileReader(fichier));
        String ligne;
        boolean lectureStations = false;

        while ((ligne = br.readLine()) != null) {
            ligne = ligne.trim();
            if (ligne.startsWith("%") && ligne.toLowerCase().contains("stations")) {
                lectureStations = true;
                continue;
            }
            if (ligne.startsWith("%") && ligne.toLowerCase().contains("connexions")) {
                break;
            }
            if (lectureStations && !ligne.isEmpty()) {
                String[] parts = ligne.split(":");
                if (parts.length >= 2) {
                    stations.add(new String[]{parts[0], parts[1]}); // id, nom
                }
            }
        }
        br.close();
        return stations;
    }
}
