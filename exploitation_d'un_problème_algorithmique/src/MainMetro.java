import java.util.*;
import java.io.*;

/**
 * Classe principale qui applique Bellman-Ford et Dijkstra à 5 trajets du métro parisien.
 * Affiche les résultats dans un tableau avec les identifiants des stations.
 */
        public class MainMetro {

            public static void main(String[] args) throws IOException {
                GrapheListe graphe = LireReseau.lire("exploitation_d'un_problème_algorithmique/Documents/plan-reseau.txt");

                // Map nom -> ID (pour affichage sous forme d'identifiants)
                Map<String, String> nomVersId = construireNomVersId("exploitation_d'un_problème_algorithmique/Documents/plan-reseau.txt");

                // Liste des trajets à tester
                List<String[]> trajets = List.of(
                        new String[]{"Château de Vincennes", "Bérault"},
                        new String[]{"Porte Dauphine", "Nation"},
                        new String[]{"Pont de Neuilly", "République"},
                        new String[]{"Concorde", "Porte d'Orléans"},
                        new String[]{"Place d'Italie", "Pont-Marie"}
                );

                // En-tête du tableau
                System.out.printf("%-25s %-25s %-35s %-25s %-25s\n",
                        "Départ", "Arrivée", "Chemin (IDs)", "Temps Bellman-Ford (ms)", "Temps Dijkstra (ms)");
                System.out.println("----------------------------------------------------------------------------------------------------------------------------");

                for (String[] trajet : trajets) {
                    String depart = trajet[0];
                    String arrivee = trajet[1];

                    // Bellman-Ford
                    long debutBF = System.nanoTime();
                    Valeurs valBF = new BellmanFord().resoudre(graphe, depart);
                    long finBF = System.nanoTime();
                    List<String> cheminBF = valBF.calculerChemin(arrivee, depart);
                    double tempsBF = (finBF - debutBF) / 1_000_000.0;

                    // Dijkstra
                    long debutD = System.nanoTime();
                    Valeurs valD = new Dijkstra().resoudre(graphe, depart);
                    long finD = System.nanoTime();
                    List<String> cheminD = valD.calculerChemin(arrivee, depart);
                    double tempsD = (finD - debutD) / 1_000_000.0;

                    // Affichage : convertir chemin en IDs
                    List<String> cheminIds = new ArrayList<>();
                    for (String nom : cheminD) {
                        cheminIds.add(nomVersId.getOrDefault(nom, "?"));
                    }

                    System.out.printf("%-25s %-25s %-35s %-25.2f %-25.2f\n",
                            depart, arrivee, String.join(" → ", cheminIds), tempsBF, tempsD);
                }
            }

            /**
             * Construit une map des noms de stations vers leurs identifiants à partir du fichier du réseau.
             * @param fichier le fichier du réseau
             * @return une map nom -> ID
             */
            public static Map<String, String> construireNomVersId(String fichier) throws IOException {
                Map<String, String> map = new HashMap<>();
                BufferedReader br = new BufferedReader(new FileReader(fichier));
                String ligne;
                boolean lectureStations = false;

                while ((ligne = br.readLine()) != null) {
                    ligne = ligne.trim();
                    if (ligne.startsWith("%") && ligne.toLowerCase().contains("stations")) {
                        lectureStations = true;
                        continue;
                    }
                    if (ligne.startsWith("%") && ligne.toLowerCase().contains("connexions")) break;
                    if (lectureStations && !ligne.isEmpty()) {
                        String[] parts = ligne.split(":");
                        if (parts.length >= 2) {
                            map.put(parts[1], parts[0]); // nom → id
                        }
                    }
                }
                br.close();
                return map;
            }
        }
