/**
 * Classe qui implémente l'algorithme de Bellman-Ford.
 *
 * Cet algorithme sert à trouver les plus courts chemins depuis un point de départ
 * vers tous les autres nœuds d'un graphe, même si certains arcs ont des coûts négatifs.
 */
public class BellmanFord {

    /**
     * Applique l'algorithme de Bellman-Ford sans pénalité de changement de ligne.
     *
     * @param g le graphe
     * @param depart le nom du noeud de départ
     * @return un objet Valeurs contenant les distances minimales et les parents
     */
    public Valeurs resoudre(Graphe g, String depart) {
        Valeurs valeurs = new Valeurs();

        // Initialisation : +inf sauf départ
        for (String noeud : g.listeNoeuds()) {
            valeurs.setValeur(noeud, noeud.equals(depart) ? 0 : Double.MAX_VALUE);
            valeurs.setParent(noeud, null);
        }

        boolean changement = true;

        // Point fixe : on boucle tant qu'on améliore
        while (changement) {
            changement = false;

            for (String noeud : g.listeNoeuds()) {
                double valeurNoeud = valeurs.getValeur(noeud);
                if (valeurNoeud == Double.MAX_VALUE) continue;

                for (Arc arc : g.suivants(noeud)) {
                    String voisin = arc.getDest();
                    double nouveauCout = valeurNoeud + arc.getCout();

                    if (nouveauCout < valeurs.getValeur(voisin)) {
                        valeurs.setValeur(voisin, nouveauCout);
                        valeurs.setParent(voisin, noeud);
                        changement = true;
                    }
                }
            }
        }

        return valeurs;
    }

    /**
     * Applique l'algorithme de Bellman-Ford avec une pénalité de 10 lors d’un changement de ligne.
     *
     * @param g le graphe
     * @param depart le nom du noeud de départ
     * @return un objet Valeurs contenant les distances minimales et les parents
     */
    public Valeurs resoudre2(Graphe g, String depart) {
        Valeurs valeurs = new Valeurs();

        // Initialisation : +inf sauf départ
        for (String noeud : g.listeNoeuds()) {
            valeurs.setValeur(noeud, noeud.equals(depart) ? 0 : Double.MAX_VALUE);
            valeurs.setParent(noeud, null);
        }

        boolean changement = true;

        // Point fixe : on boucle tant qu'on améliore
        while (changement) {
            changement = false;

            for (String noeud : g.listeNoeuds()) {
                double valeurNoeud = valeurs.getValeur(noeud);
                if (valeurNoeud == Double.MAX_VALUE) continue;

                for (Arc arc : g.suivants(noeud)) {
                    String voisin = arc.getDest();
                    double cout = arc.getCout();

                    // Vérifie changement de ligne
                    String parent = valeurs.getParent(noeud);
                    if (parent != null) {
                        for (Arc arcVersNoeud : g.suivants(parent)) {
                            if (arcVersNoeud.getDest().equals(noeud)) {
                                String ligneAvant = arcVersNoeud.getLigne();
                                String ligneActuelle = arc.getLigne();

                                if (ligneAvant != null && ligneActuelle != null &&
                                        !ligneAvant.equals(ligneActuelle)) {
                                    cout += 10; // pénalité de changement de ligne
                                }
                                break;
                            }
                        }
                    }

                    double nouveauCout = valeurNoeud + cout;

                    if (nouveauCout < valeurs.getValeur(voisin)) {
                        valeurs.setValeur(voisin, nouveauCout);
                        valeurs.setParent(voisin, noeud);
                        changement = true;
                    }
                }
            }
        }

        return valeurs;
    }

    /**
     * Retourne le coût total du chemin entre depart et destination,
     * en utilisant les valeurs calculées par l'algorithme de Bellman-Ford.
     *
     * @param depart       la station de départ
     * @param destination  la station d'arrivée
     * @param valeurs      l'objet Valeurs retourné par resoudre()
     * @return le coût total du chemin, ou Double.MAX_VALUE si aucun chemin n'existe
     */
    public double coutChemin(String depart, String destination, Valeurs valeurs) {
        // Vérification si un chemin existe
        if (valeurs.getValeur(destination) == Double.MAX_VALUE || valeurs.getParent(destination) == null) {
            return Double.MAX_VALUE; // Aucun chemin trouvé
        }

        return valeurs.getValeur(destination);
    }

}
