public  class BellmanFord {
    /**
     * Méthode pour appliquer l'algorithme de Bellman-Ford (point fixe).
     *
     * @param g le graphe sur lequel on travaille
     * @param depart le nom du noeud de départ
     * @return un objet Valeurs contenant les distances minimales et les parents
     */
    public Valeurs resoudre(Graphe g, String depart) {
        Valeurs valeurs = new Valeurs(); // Création de l'objet Valeurs pour stocker

        // 1. Initialisation : on met toutes les distances à +infini sauf celle du départ (0)
        for (String noeud : g.listeNoeuds()) {
            if (noeud.equals(depart)) {
                valeurs.setValeur(noeud, 0); // Le départ est à distance 0
                valeurs.setParent(noeud, null); // Pas de parent pour le point de départ
            } else {
                valeurs.setValeur(noeud, Double.MAX_VALUE); // Distance infinie
                valeurs.setParent(noeud, null); // Parent inconnu au début
            }
        }

        boolean changement = true;

        // 2. Boucle principale : on répète tant qu'il y a des changements
        while (changement) {
            changement = false;

            // Pour chaque noeud du graphe
            for (String noeud : g.listeNoeuds()) {
                double valeurNoeud = valeurs.getValeur(noeud);

                // Si la valeur est encore infinie, on ne peut rien faire depuis ce noeud
                if (valeurNoeud == Double.MAX_VALUE) ; // on continue sans traiter les arcs de ce noeud

                // Pour chaque arc sortant de ce noeud
                for (Arc arc : g.suivants(noeud)) {
                    String voisin = arc.getDest();
                    double nouveauCout = valeurNoeud + arc.getCout();

                    // Si on trouve un meilleur chemin vers le voisin, on met à jour
                    if (nouveauCout < valeurs.getValeur(voisin)) {
                        valeurs.setValeur(voisin, nouveauCout); // Meilleure distance
                        valeurs.setParent(voisin, noeud);       // Meilleur parent
                        changement = true;                      // Un changement a eu lieu
                    }
                }
            }
        }

        // 3. Retour des résultats finaux (distances et parents)
        return valeurs;
    }
}

