/**
 * Classe qui implémente l'algorithme de Bellman-Ford.
 *
 * Cet algorithme sert à trouver les plus courts chemins depuis un point de départ
 * vers tous les autres nœuds d'un graphe, même si certains arcs ont des coûts négatifs.
 */

public  class BellmanFord {
    /**
     * Méthode pour appliquer l'algorithme de Bellman-Ford (point fixe).
     *
     * @param g le graphe sur lequel on travaille
     * @param depart le nom du noeud de départ
     * @return un objet Valeurs contenant les distances minimales et les parents
     */
    public Valeurs resoudre(Graphe g, String depart) {
        Valeurs valeurs = new Valeurs(); // Création de l'objet Valeurs pour stocker

        // 1. Initialisation : on met toutes les distances à +infini sauf celle du départ (0)
        for (String noeud : g.listeNoeuds()) {
            if (noeud.equals(depart)) {
                valeurs.setValeur(noeud, 0); // Le départ est à distance 0
                valeurs.setParent(noeud, null); // Pas de parent pour le point de départ
            } else {
                valeurs.setValeur(noeud, Double.MAX_VALUE); // Distance infinie
                valeurs.setParent(noeud, null); // Parent inconnu au début
            }
        }

        boolean changement = true;

        // 2. Boucle principale : on répète tant qu'il y a des changements
        while (changement) {
            changement = false;

            // Pour chaque noeud du graphe
            for (String noeud : g.listeNoeuds()) {
                double valeurNoeud = valeurs.getValeur(noeud);

                // Si la valeur est encore infinie, on ne peut rien faire depuis ce noeud
                if (valeurNoeud == Double.MAX_VALUE) ; // on continue sans traiter les arcs de ce noeud

                // Pour chaque arc sortant de ce noeud
                for (Arc arc : g.suivants(noeud)) {
                    String voisin = arc.getDest();
                    double nouveauCout = valeurNoeud + arc.getCout();

                    // Si on trouve un meilleur chemin vers le voisin, on met à jour
                    if (nouveauCout < valeurs.getValeur(voisin)) {
                        valeurs.setValeur(voisin, nouveauCout); // Meilleure distance
                        valeurs.setParent(voisin, noeud);       // Meilleur parent
                        changement = true;                      // Un changement a eu lieu
                    }
                }
            }
        }

        // 3. Retour des résultats finaux (distances et parents)
        return valeurs;
    }


    /**
     * Méthode pour appliquer l'algorithme de Bellman-Ford (point fixe).
     * Ici on mettera une penalité de 10 si on change de ligne
     *
     * @param g le graphe sur lequel on travaille
     * @param depart le nom du noeud de départ
     * @return un objet Valeurs contenant les distances minimales et les parents
     */
    public Valeurs resoudre2(Graphe g, String depart) {
        Valeurs valeurs = new Valeurs(); // Création de l'objet Valeurs pour stocker

        // 1. Initialisation : on met toutes les distances à +infini sauf celle du départ (0)
        for (String noeud : g.listeNoeuds()) {
            if (noeud.equals(depart)) {
                valeurs.setValeur(noeud, 0); // Le départ est à distance 0
                valeurs.setParent(noeud, null); // Pas de parent pour le point de départ
            } else {
                valeurs.setValeur(noeud, Double.MAX_VALUE); // Distance infinie
                valeurs.setParent(noeud, null); // Parent inconnu au début
            }
        }

        boolean changement = true;

        // 2. Boucle principale : on continue tant qu'il y a eu un changement
        while (changement) {
            changement = false;

            // Pour chaque noeud du graphe
            for (String noeud : g.listeNoeuds()) {
                double valeurNoeud = valeurs.getValeur(noeud);

                // Si on ne connaît pas encore de distance vers ce noeud, on le saute
                if (valeurNoeud == Double.MAX_VALUE) continue;

                // Pour chaque arc sortant de ce noeud
                for (Arc arc : g.suivants(noeud)) {
                    String voisin = arc.getDest();
                    double cout = arc.getCout();

                    // Vérifier changement de ligne par rapport au parent de ce noeud
                    String parent = valeurs.getParent(noeud);
                    if (parent != null) {
                        // On cherche l’arc parent → noeud
                        for (Arc arcVersNoeud : g.suivants(parent)) {
                            if (arcVersNoeud.getDest().equals(noeud)) {
                                String ligneAvant = arcVersNoeud.getLigne();
                                String ligneActuelle = arc.getLigne();

                                if (ligneAvant != null && ligneActuelle != null
                                        && !ligneAvant.equals(ligneActuelle)) {
                                    cout += 10; // pénalité de changement de ligne
                                }
                                break;
                            }
                        }
                    }

                    double nouveauCout = valeurNoeud + cout;

                    // Si ce nouveau chemin est meilleur, on met à jour
                    if (nouveauCout < valeurs.getValeur(voisin)) {
                        valeurs.setValeur(voisin, nouveauCout);
                        valeurs.setParent(voisin, noeud);
                        changement = true; // Un changement a eu lieu, il faudra une autre passe
                    }
                }
            }
        }

        // 3. Retour des résultats finaux (distances et parents)
        return valeurs;
    }
}

