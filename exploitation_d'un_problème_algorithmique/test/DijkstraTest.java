import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class DijkstraTest {

    @Test
    public void testDijkstra() {
        GrapheListe graphe = new GrapheListe();

        // Construction du même graphe que pour Bellman-Ford
        graphe.ajouterArc("A", "B", 12);
        graphe.ajouterArc("A", "D", 87);
        graphe.ajouterArc("B", "E", 11);
        graphe.ajouterArc("C", "A", 19);
        graphe.ajouterArc("D", "C", 10);
        graphe.ajouterArc("D", "B", 23);
        graphe.ajouterArc("E", "D", 43);

        Dijkstra algo = new Dijkstra();
        Valeurs resultats = algo.resoudre(graphe, "A");

        // Vérification des distances attendues
        assertEquals(0.0, resultats.getValeur("A"), 0.0001);
        assertEquals(12.0, resultats.getValeur("B"), 0.0001);
        assertEquals(66.0, resultats.getValeur("D"), 0.0001);
        assertEquals(76.0, resultats.getValeur("C"), 0.0001);
        assertEquals(23.0, resultats.getValeur("E"), 0.0001);

        // Vérification des parents
        assertNull(resultats.getParent("A"));      // point de départ
        assertEquals("A", resultats.getParent("B"));
        assertEquals("E", resultats.getParent("D"));
        assertEquals("D", resultats.getParent("C"));
        assertEquals("B", resultats.getParent("E"));
    }
    @Test
    public void testSommetInaccessible() {
        GrapheListe graphe = new GrapheListe();

        graphe.ajouterArc("A", "B", 5);
        graphe.ajouterArc("B", "C", 10);
        graphe.ajouterArc("D", "E", 2); // D et E sont isolés

        Dijkstra algo = new Dijkstra();
        Valeurs resultats = algo.resoudre(graphe, "A");

        // A peut atteindre B et C
        assertEquals(0.0, resultats.getValeur("A"), 0.0001);
        assertEquals(5.0, resultats.getValeur("B"), 0.0001);
        assertEquals(15.0, resultats.getValeur("C"), 0.0001);

        // D et E sont inaccessibles, donc distance infinie
        assertEquals(Double.MAX_VALUE, resultats.getValeur("D"), 0.0001);
        assertEquals(Double.MAX_VALUE, resultats.getValeur("E"), 0.0001);

        assertNull(resultats.getParent("A"));
        assertEquals("A", resultats.getParent("B"));
        assertEquals("B", resultats.getParent("C"));
        assertNull(resultats.getParent("D"));
        assertNull(resultats.getParent("E"));
    }

    @Test
    public void testCycle() {
        GrapheListe graphe = new GrapheListe();

        graphe.ajouterArc("A", "B", 1);
        graphe.ajouterArc("B", "C", 1);
        graphe.ajouterArc("C", "A", 1); // cycle A → B → C → A

        Dijkstra algo = new Dijkstra();
        Valeurs resultats = algo.resoudre(graphe, "A");

        assertEquals(0.0, resultats.getValeur("A"), 0.0001);
        assertEquals(1.0, resultats.getValeur("B"), 0.0001);
        assertEquals(2.0, resultats.getValeur("C"), 0.0001);

        assertNull(resultats.getParent("A"));
        assertEquals("A", resultats.getParent("B"));
        assertEquals("B", resultats.getParent("C"));
    }

    @Test
    public void testCheminsEquivalents() {
        GrapheListe graphe = new GrapheListe();

        graphe.ajouterArc("A", "B", 5);
        graphe.ajouterArc("A", "C", 5);
        graphe.ajouterArc("B", "D", 5);
        graphe.ajouterArc("C", "D", 5); // Deux chemins A → B → D et A → C → D (même coût)

        Dijkstra algo = new Dijkstra();
        Valeurs resultats = algo.resoudre(graphe, "A");

        assertEquals(0.0, resultats.getValeur("A"), 0.0001);
        assertEquals(5.0, resultats.getValeur("B"), 0.0001);
        assertEquals(5.0, resultats.getValeur("C"), 0.0001);
        assertEquals(10.0, resultats.getValeur("D"), 0.0001);

        assertNull(resultats.getParent("A"));
        assertEquals("A", resultats.getParent("B"));
        assertEquals("A", resultats.getParent("C"));

        // le parent de D peut être soit B soit C (au choix)
        String parentD = resultats.getParent("D");
        assertTrue(parentD.equals("B") || parentD.equals("C"));
    }

}
